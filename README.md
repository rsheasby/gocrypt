# gocrypt
Opinionated Go library for scalable, secure password hashing

## What does this do?
It provides an opinionated, simple, secure method of hashing passwords using separate hashing processes that can be scaled independently of your backend. This keeps all your non-login requests responsive and fast since the hashing isn't hogging the CPU, and queues up all authentication requests to be executed in a scalable way, so that they can be distributed and dealt with as soon as more hashing power is available.

## What problem does this solve?
The goal of password hashing is to increase the computational cost of each password authenticaion, thereby slowing down a brute force attack in the event of a database breach or malicious employee with database access. However, this computaional cost comes with a problem at scale. A well-tuned password hash should take at least half a second to complete(on one core), resulting in only a couple authentications per second. In some cases, these user authentications will come all at once, like when a mass email is sent out to your users, prompting them to login. This spike of requests can cause a significant increase in response times for all requests, and bring the whole application to a halt. Of course, you could just scale out your backend to spread out the load, but how many requests will timout in the time it takes to deploy new backend processes? When deploying new backend processes, the existing requests don't get redistributed to the new backends, so this is a reactionary measure. Also, even if you have enough backends, the long-running CPU task of hashing the passwords can increase the response time of other requests, as they wait for CPU time to become available. By queuing the hash requests to be run by dedicated runners, we avoid all these problems .

## What's under the hood?
gocrypt uses Redis for communication between the backend and the hashers. SHA512 is used to hash the passwords before they are sent to the hashers. This provides basic obfuscation of the passwords in the queue, and allows arbitrary password lengths. Bcrypt is then used for the final password hashing. Bcrypt was chosen for its resistance to GPU acceleration, and the simple single parameter cost tuning. It's also taken a lot of cryptographic scrutiny, and it's held up pretty well so far.
